MINIGAME DEEP DIVE
How each minigame will work at a deep level, and how we're going to implement it. It's gone over a little bit in the game outline, but this document is for more detail than that, and can be changed as we solidify what each minigame is.

COOKING
The player goes to a cooking station, and uses the action button. A sceen pops up allowing them to choose ingredients, and to look at recipes that they have. Once they have chosen the ingredients, the game cuts to a new screen.
In this new screen, only one player is in control. There is a fire at the bottom of the screen, and the player controls a frying pan. at the top of the screen, the next ingredient to be added is shown, as well as the one after, if there is one. Ingredients enter from the left of the screen every few seconds, and the player needs to move the frying pan back and forth to bounce them up and away from the fire. Each ingredient has a bar at the bottom indicating how cooked it is relative to its optimum level. Once the player is satisfied with how cooked an ingredient is, they can try to bounce it off to the right of the screen. Once every ingredient has been bounced away or burnt, a pop-up shows up declaring what recipe you cooked, how good it is, how long it will go without spoiling, and how much hunger it restores. Foods that taste better can be sold for more money than blander ones. Burnt food or food cooked with rotten ingredients may actually cause damage.

Implementation: ingredient selection UI, new world, next and on deck food indicator, player controlled frying pan sprite with 3-5 contact boxes that propel the ingredients in different directions, collisionArea on the right to detect if food has been sent to the cooked area, fire animation + collisionArea for burnt food, instanced Ingredient objects (with their own type, correct cooking time, current cooking time, bounce value, collisionArea, and 3+ sprites- raw, cooked, burnt), semi-random ingredient instancer, and gravity.

FISHING
The player goes to an appropriate water source, and uses the action button. If the other player is nearby, they will be asked if they want to fish too, in which case both players can fish at the same time. In this case, each player controls a hook, we can make them be different colors to help distinguish them. Obstacles spawn and move upwards, giving the hooks the appearance of going down. A depth counter at the top indicates how deep the hooks have gone. As the depth goes up, the speed of the obstacles increases and the size of the fish does as well. Different fishing locations have different max depths, different sized fish, and different spawn rates for fish, but when the max depth is reached, there is always a big fish (or two if both players made it), and obstacles stop coming. If all the players playing have touched their hook to a fish, then they have to bring the hook back up to the surface without getting stuck. If only one of the two players catches a fish and the other is still going, their hook and fish stay where they are until the other player catches them on the way up or gets stuck. Any time a player gets their hook stuck, there is a chance that the hook is lost and taken from the inventory.

Implementation: Draw out all the obstacles and spawn all the fish at the start, not on the fly. One or two player controlled hooks, obstacles moving up until max depth is reached and they stop, obstacle randomization algorithm, CollisionAreas on all sides of the viewpane that only interact with the hooks. Fish collision system. Random hook destruction feature.

HUNTING
A player goes up to animal tracks and presses the action button. They then hunt with whatever weapon they had equipped, for better or worse. The screen changes to a chase, with the animal on the right and a single player on the left, trying to maintain the right distance. The animal moves around randomly to make this more difficult. At the top of the screen, there are three meters: lose, shot, and spook. The lose meter fills up when the player is too far away, and drains when they're in good range or too close. The spook meter is the opposite. The shot meter fillswhen the player is in the right position for long enough. Once it fills, a pop-up comes up alerting the player to their chance to hit the animal and how much health it has left. The player has the choice to take the shot (and lose 1 ammo for whatever it is they're using) or give up. The hunting value of the weapon impacts the chance to hit, and its damage and the animal's individual health impact those values, respectively. Alternatively, we could add a quicktime event for this. The closer to the middle the bullseye is hit, the more damage is done. Once the animal goes down, the player returns to the exploring screen, only now where the tracks were there is an animal corpse to loot for pelt, bone, and meat. Different animals charge the meters differently and have different amounts of health, and may move at different speeds, as well as giving up different items upon death.

Implementation: player sprite + animations (could be same as exploration), animal sprite +animations. 3 separate collision areas for the animal, 3 progress bars- maybe radial ones. Background moving to make it look like a dynamic chase. Shot chance function or quicktime event.

LOCKPICKING
Only takes up half the screen so the other player can explore while one does this. Depending on the difficulty of the lock, there are 2 to 6 pins that need to be solved. The player makes a guess by taking a paper clip and assigning values from 2 to -2 for each pin. They can then click the "try" button, and they are told how many pins were correct but in the wrong position, how many were correct in the right position, and how many were wrong. The player can then choose to use a new paper clip or bend the current one again, which can survive a total of 24 points' worth of bending (which would be bending it 2 or -2 in every place once and then bending it straight again once on a 6-pin lock). Once the player chooses to pick out a new paper clip, the old one is removed from the inventory.

Implementation: dynamic UI with more or less pins (probably multiple UIs or a modular one), lock random code generation, paper clip art, new paper clip mechanic, reporting function

FARMING
The minigame begins with the player choosing what plant they want to farm. Both players can select differnt plants if they like. The field is a grid with squares where plants can go, but the players can both move around in it freely. They have four tools- a hoe (for killing varmints), a seed bucket (for planting seeds), a harvest basket (for collecting crops when they're ready) and a watering can (for keeping plants alive). The players get 3 minutes to plant as many seeds as possible, water them, keep them alive until they grow big enough, and collect them. Varmints (maybe birds, maybe giant bugs, maybe just weeds?) come and eat plants, killing them, and plants dies on their own if left without water long enough. Players need to go back and forth to the shed to grab the appropriate tool for what they need to do- maybe initially both of them plant seeds, then one waters and the other hoes, and then at harvest time one player harvests while the other plants more seeds. It's entirely up to them, but it should be tough to do alone and it should reward players for specializingrather than running back and forth to the shed.

Implementation: grid for plants, plant water and health meters, varmint AI, varmint killing mechanic (hack and slash), varmint animations, water can mechanic, planting mechanic, harvesting mechanic, tool switching mechanic, farming player models and animations, updated inventory after completing minigame, seed selection UI

ANIMAL RACES
The minigame begins with placing bets. A screen shows up with all of the animals' names, their odds, and their record in the last 5 races. Under the hood, they have a max speed, a min speed, how many races they have left before they retire, and a consistency rating that decides how often they go at top speed. The players can bet on as many animals as they want, and once they click the "race!" button, the screen changes to all of the animals in lanes, like a track meet, going from left to right. Players get some money if their bet places (2nd or 3rd) and the maximum from their odds if the animal wins. Once an animal's races left value reaches 0, they retire and are replaced by procedurally generated new ones. Maybe if they bet on the winner, we can have the player get gifted a certificate on top of their winnings that has a picture of the animal they betted on and the finish order. We need to decide what kind of animals they would be- pigs? rats? frogs? dogs? fish?

Implementation: betting UI, betting (keeping the player from betting more than they have), procedural animal generation, cutting to and from the race scene, the actual race (checking speed, checking who finishes, making them stop when they finish and reporting the results), lots of assets

HOCKEY
Very fancy air hockey. The playing area is divided into 3 zones: offensive, defensive, and faceoff. In the defensive zone, the players control 2 defensemen, and the goalie is AI. In the offensive zone, the players control 2 forwards. The team in the defensive zone wants to get the puck out of their zone by getting it to the red line (in which case they go on offense), while the attacking team wants to get the puck into the much smaller goal. After goals and to start each period, the play happens in the neutral zone, with the puck in the middle, both teams controlling 2 forwards, and both sides trying to get the puck over the blue line. Just like in regular air hockey, players can't cross over the halfway point which is marked by blue lines. Players can run into one another at the blue line, which carries a chance of starting a fight. If there is a fight, then the game cuts to a modified version of the combat scene. The loser of a fight is removed from the game. Players are controlled with the keys, and each have 4 skills, and a handedness: skating (how fast they move), shooting (how fast the puck moves when they hit it with their stick), aggression (how likely they are to spark a fight from a collision), and fighting (their health and how much damage their punches do in a fight), and left or right handedness (players keep their stick to one side and shoot the puck much harder when it hits their stick than when it hits their body). Teams consist of 6 forwards, 4 defensemen, and a goalie. The game is divided into 3 timed periods, and at the start of each, the players get to choose which 4 forwards and 3 defensemen will play that period. Each time the puck changes zones, the players change: the two forwards who didn't play last time come in, and the defensemen rotate. If a player loses a fight, he is replaced by one of the subs not chosen for the period. Once a team runs out of subs, they can't fight anymore (max 3 fights per game). When the defensive team clears the puck, it maintains its momentum, meaning that defensemen and even goalies can score if the other team isn't ready.
As part of the Keggley Cup quast and sub-quests, we may want to keep stats for individual players goals, fights, fights won, and saves and goals against for goalies. I dunno.

Implementation: between-period player selection UI, player rotation mechanic, player ejection mechanic, player movement + puck collision, transitioning into fights (ties into ejection), modified combat scene, goals and scoreboard, AI (should be pretty easy to find air hockey AIs to modify), zone movement mechanic, clock and periods, player models with two collision boxes fot body + stick, aggression mechanic, statkeeping (maybe).

TENNIS (maybe table tennis instead?):
Fancy pong. We could have doubles or singles. The players move with the keyboard, and press the swing button to time their swings, which affects where the ball goes. If the ball goes past them, it's the other player/couple's point. Serves are a two-part quicktime event, first choosing the direction and then the power of the shot. Having good serves and scoring builds up the special shot meter, which allows the player to do a special shot like curving the ball or making it zig-zag.

Implementation: player or players that move around, shot timing/aim mechainc, ball collision and bouncing off the walls, scoreboard and scoring from ball crossing into collision area, AI (should be easy), meter and function for special shots.

BASKETBALL
Essentialyly a simplified blood bowl. Both teams have 3 players, and take turns moving their players around in order to score. Games are played to 21, with shots being worth 2 or 3 points. Each player has 6 skills: how far they can move, how far they can pass, how good they are at shooting from range, how good they are at shooting up close, how good they are at stealing, and how good they are at blocking shots. Once a player has passed, shot, or attempted a steal, he can no longer move. To pass, the player selects whoever is controlling the ball, the spaces where he can pass are highlighted, and the ball goes to the selected space. If no player is in that space, then the ball sits there, uncontrolled. If someone is there, they have the ball. Players can always shoot, and depending on their stats and their defenders, there is a percentage chance of the shot going in and a chance of it getting blocked. In order to try to steal the ball, a defensive player must be moved to the space adjacent to the ball carrier. If a player gets his shot blocked, he becomes demoralized and all of his skills go down by one. Stealing is also a percentage chance, based on the defender's steal rating. A player's turn ends if they score a basket, if all three of their players have exhausted all their actions, or if they choose to end their turn.

Implementation: Turn system, grid mechanics, skill checks and skills, scoreboard, player models (probably not many animations).

MUSIC
Guitar hero timing-based game. P1 and P2 both have 4 keys to press in time (because they play "different instruments"). Having a higher score makes the gig go better, which results in more pay for paid gigs or a successful event in certain quests.

DRUGS
?
Implementation: ?


POOL
?
Implementation: ?

OTHER GAMBLING GAMES
?

Implementation: ?

