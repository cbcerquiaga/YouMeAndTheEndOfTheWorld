MINIGAME DEEP DIVE
How each minigame will work at a deep level, and how we're going to implement it. It's gone over a little bit in the game outline, but this document is for more detail than that, and can be changed as we solidify what each minigame is.

COOKING
The player goes to a cooking station, and uses the action button. A sceen pops up allowing them to choose ingredients, and to look at recipes that they have. Once they have chosen the ingredients, the game cuts to a new screen.
In this new screen, only one player is in control. There is a fire at the bottom of the screen, and the player controls a frying pan. at the top of the screen, the next ingredient to be added is shown, as well as the one after, if there is one. Ingredients enter from the left of the screen every few seconds, and the player needs to move the frying pan back and forth to bounce them up and away from the fire. Each ingredient has a bar at the bottom indicating how cooked it is relative to its optimum level. Once the player is satisfied with how cooked an ingredient is, they can try to bounce it off to the right of the screen. Once every ingredient has been bounced away or burnt, a pop-up shows up declaring what recipe you cooked, how good it is, how long it will go without spoiling, and how much hunger it restores. Foods that taste better can be sold for more money than blander ones. Burnt food or food cooked with rotten ingredients may actually cause damage.

Implementation: ingredient selection UI, new world, next and on deck food indicator, player controlled frying pan sprite with 3-5 contact boxes that propel the ingredients in different directions, collisionArea on the right to detect if food has been sent to the cooked area, fire animation + collisionArea for burnt food, instanced Ingredient objects (with their own type, correct cooking time, current cooking time, bounce value, collisionArea, and 3+ sprites- raw, cooked, burnt), semi-random ingredient instancer, and gravity.

FISHING
The player goes to an appropriate water source, and uses the action button. If the other player is nearby, they will be asked if they want to fish too, in which case both players can fish at the same time. In this case, each player controls a hook, we can make them be different colors to help distinguish them. Obstacles spawn and move upwards, giving the hooks the appearance of going down. A depth counter at the top indicates how deep the hooks have gone. As the depth goes up, the speed of the obstacles increases and the size of the fish does as well. Different fishing locations have different max depths, different sized fish, and different spawn rates for fish, but when the max depth is reached, there is always a big fish (or two if both players made it), and obstacles stop coming. If all the players playing have touched their hook to a fish, then they have to bring the hook back up to the surface without getting stuck. If only one of the two players catches a fish and the other is still going, their hook and fish stay where they are until the other player catches them on the way up or gets stuck. Any time a player gets their hook stuck, there is a chance that the hook is lost and taken from the inventory.

Implementation: Draw out all the obstacles and spawn all the fish at the start, not on the fly. One or two player controlled hooks, obstacles moving up until max depth is reached and they stop, obstacle randomization algorithm, CollisionAreas on all sides of the viewpane that only interact with the hooks. Fish collision system. Random hook destruction feature.

HUNTING
A player goes up to animal tracks and presses the action button. They then hunt with whatever weapon they had equipped, for better or worse. The screen changes to a chase, with the animal on the right and a single player on the left, trying to maintain the right distance. The animal moves around randomly to make this more difficult. At the top of the screen, there are three meters: lose, shot, and spook. The lose meter fills up when the player is too far away, and drains when they're in good range or too close. The spook meter is the opposite. The shot meter fillswhen the player is in the right position for long enough. Once it fills, a pop-up comes up alerting the player to their chance to hit the animal and how much health it has left. The player has the choice to take the shot (and lose 1 ammo for whatever it is they're using) or give up. The hunting value of the weapon impacts the chance to hit, and its damage and the animal's individual health impact those values, respectively. Alternatively, we could add a quicktime event for this. The closer to the middle the bullseye is hit, the more damage is done. Once the animal goes down, the player returns to the exploring screen, only now where the tracks were there is an animal corpse to loot for pelt, bone, and meat. Different animals charge the meters differently and have different amounts of health, and may move at different speeds, as well as giving up different items upon death.

Implementation: player sprite + animations (could be same as exploration), animal sprite +animations. 3 separate collision areas for the animal, 3 progress bars- maybe radial ones. Background moving to make it look like a dynamic chase. Shot chance function or quicktime event.

LOCKPICKING
Only takes up half the screen so the other player can explore while one does this. Depending on the difficulty of the lock, there are 2 to 6 pins that need to be solved. The player makes a guess by taking a paper clip and assigning values from 2 to -2 for each pin. They can then click the "try" button, and they are told how many pins were correct but in the wrong position, how many were correct in the right position, and how many were wrong. The player can then choose to use a new paper clip or bend the current one again, which can survive a total of 24 points' worth of bending (which would be bending it 2 or -2 in every place once and then bending it straight again once on a 6-pin lock). Once the player chooses to pick out a new paper clip, the old one is removed from the inventory.

Implementation: dynamic UI with more or less pins (probably multiple UIs or a modular one), lock random code generation, paper clip art, new paper clip mechanic, reporting function

FARMING
The minigame begins with the player choosing what plant they want to farm. Both players can select differnt plants if they like. The field is a grid with squares where plants can go, but the players can both move around in it freely. They have four tools- a hoe (for killing varmints), a seed bucket (for planting seeds), a harvest basket (for collecting crops when they're ready) and a watering can (for keeping plants alive). The players get 3 minutes to plant as many seeds as possible, water them, keep them alive until they grow big enough, and collect them. Varmints (maybe birds, maybe giant bugs, maybe just weeds?) come and eat plants, killing them, and plants dies on their own if left without water long enough. Players need to go back and forth to the shed to grab the appropriate tool for what they need to do- maybe initially both of them plant seeds, then one waters and the other hoes, and then at harvest time one player harvests while the other plants more seeds. It's entirely up to them, but it should be tough to do alone and it should reward players for specializingrather than running back and forth to the shed.

Implementation: grid for plants, plant water and health meters, varmint AI, varmint killing mechanic (hack and slash), varmint animations, water can mechanic, planting mechanic, harvesting mechanic, tool switching mechanic, farming player models and animations, updated inventory after completing minigame, seed selection UI

ANIMAL RACES
The minigame begins with placing bets. A screen shows up with all of the animals' names, their odds, and their record in the last 5 races. Under the hood, they have a max speed, a min speed, how many races they have left before they retire, and a consistency rating that decides how often they go at top speed. The players can bet on as many animals as they want, and once they click the "race!" button, the screen changes to all of the animals in lanes, like a track meet, going from left to right. Players get some money if their bet places (2nd or 3rd) and the maximum from their odds if the animal wins. Once an animal's races left value reaches 0, they retire and are replaced by procedurally generated new ones. Maybe if they bet on the winner, we can have the player get gifted a certificate on top of their winnings that has a picture of the animal they betted on and the finish order. We need to decide what kind of animals they would be- pigs? rats? frogs? dogs? fish?

Implementation: betting UI, betting (keeping the player from betting more than they have), procedural animal generation, cutting to and from the race scene, the actual race (checking speed, checking who finishes, making them stop when they finish and reporting the results), lots of assets

HOCKEY
Essentially a 2D version of rocket league, played from a top-down view. At the start of the game, the players each choose a player to control for that period from their team's roster. The AI does the same, and the game is played between 2 skaters and a goalie for each team. Players are operated with only arrow keys/WSAD, and maneuver like cars- pressing up increases speed (and releasing it slows down), back lets the player stop, left and right turn. Double tapping up should have players lunge to hit opponents or the puck, and double tapping left or right should have the player spin around to skate backwards. Both players for both teams hit the puck like an air hockey paddle- they just kind of smack into it. Unlike air hockey, the players should have rectangular hitboxes and free reign of the entire playing surface (except the goalies who are glued to their area and just use air hockey AI). If a player does a lunge at another player and hits them, they knock that player down (we can add some depth like a hitting/balance skill or a speed check or something). If a player gets knocked down enough, they will fight whoever just hit them. Whenever players get hit during the game they lose health for the fighting (maybe they have a toughness stat?). If there is a fight, then the game cuts to a modified version of the combat scene. The loser of a fight is removed from the game (and can't come back until the next game) and replaced by a new player (there should be a limit to how many fights can be in a game though, maybe 3). The game is played in 3x2 minute periods(or some other amount of time) and inbetween periods, players can choose new players to play with.
The simple nature ouf the game should make it playable for everybody, but I think players could get pretty deep into strategies if they wanted. For example, a good strategy would be to play as fighters and take out the other team's best players in the 1st and then try to score in the 2nd and 3rd.
I think it would make sense for players to have 3 skills- skating (speed and turning), hitting (lunge range/knockdown chance/damage?), and toughness(health drain/punch power) as a simple way to differentiate players and add variety to the game. We can have 3 basic classes- forwards (more skating), defensemen (more hitting), and enforcers (more fighting). Goalies should probably always be the same.
As part of the Keggley Cup quast and sub-quests, we may want to keep stats for individual players goals, fights, fights won, and saves and goals against for goalies. I dunno.

Implementation: between-period player selection UI, player ejection mechanic, player movement + puck collision, transitioning into fights (ties into ejection), modified combat scene, goals and scoreboard, AI (should be pretty easy to find air hockey AIs to modify), car-style movement, clock and periods, player skills and game balancing, hitting mechanic, statkeeping (maybe).

TENNIS (maybe table tennis instead?):
Pong/air hockey. We could have doubles or singles. The players move with the keyboard. If the ball goes past them, it's the other player/couple's point. Serves are a two-part quicktime event, first choosing the direction and then the power of the shot. Having good serves and scoring builds up the special shot meter, which allows the player to do a special shot like curving the ball or making it zig-zag.

Implementation: player or players that move around, ball collision and bouncing off the walls, scoreboard and scoring from ball crossing into collision area, AI (should be easy), meter and function for special shots.

BASKETBALL
Essentialyly a simplified blood bowl. Both teams have 3 players, and take turns moving their players around in order to score. Games are played to 21, with shots being worth 2 or 3 points. Each player has 6 skills: how far they can move, how far they can pass, how good they are at shooting from range, how good they are at shooting up close, how good they are at stealing, and how good they are at blocking shots. Once a player has passed, shot, or attempted a steal, he can no longer move. To pass, the player selects whoever is controlling the ball, the spaces where he can pass are highlighted, and the ball goes to the selected space. If no player is in that space, then the ball sits there, uncontrolled. If someone is there, they have the ball. Players can always shoot, and depending on their stats and their defenders, there is a percentage chance of the shot going in and a chance of it getting blocked. In order to try to steal the ball, a defensive player must be moved to the space adjacent to the ball carrier. If a player gets his shot blocked, he becomes demoralized and all of his skills go down by one. Stealing is also a percentage chance, based on the defender's steal rating. A player's turn ends if they score a basket, if all three of their players have exhausted all their actions, or if they choose to end their turn.

Implementation: Turn system, grid mechanics, skill checks and skills, scoreboard, player models (probably not many animations), AI.

ALT: Basketball
In case we don't like the turn based style, or it's too hard to make, we can do it this way.
The game is played in a side view on half a court, with the basket on the right side. Each team has 2 players- a guard who stands far away from the basket, and a center who stands near the basket. Players don't move their characters around the court- their action buttons correlate to skills and the game is entirely based on timing. If a player has the ball, they have 4 moves they can do: shoot it (which requires a timing meter), pass it to their teammate, fake shooting it, or fake passing it. The player guarding them can attempt to block the passing lane or jump to block a shot- both leave the player exposed to the other action though. The two players away from the ball have 3 choices (that act as a sort of rock-paper-scissors): jump for a rebound, shove the other player, and dodge away. If the defensive team gets the ball, the guard needs to touch the ball in order to "take it back". Whether or not a shot goes in should depend on a skill check, it not getting blocked, the timing of the shot, whether or not the shot was almost blocked (contesting it should hurt its chances of going in), and a bit of random chance. Games should be played to 11 or 21. Shots from the guards should be worth 2 points, but harder to make, and shots from the center should be 1 point but easier to make (though then you have to get past both players instead of just one).

Implementation: ball possession mechanic, shot timing meter, shot sccoring mechanic, timing and collisions, scoreboard, player models (not many animations), basic AI, 

MUSIC
Guitar hero style timing-based game. P1 and P2 both have 4 keys to press in time (because they play "different instruments"). Having a higher score makes the gig go better, which results in more pay for paid gigs or a successful event in certain quests.

Implementation: song reading (maybe random song generation for "jam sessions"), UI, timing check, music sounds, music error sounds

DRUGS
?
Implementation: ?


POOL
Players can play either cooperatively (taking turns against the AI), alone (only one player vs the AI) or against one another. Rather than cutting to a different scene, I think players should navigate normally around the table, with the angle they take shooting the cue ball to change based on where they stand, and their power being based on how long they hold down the action button. This way, in a dialog-rich environment like a bar, one player could play pool while the other talks to people, and the pool experience would be more immersive.
Implementation: pool cue item to temporarily equip, sending cueball in angular directions, measuring button hold time, pocket sinking mechanic, turn taking and rules, AI figuring out which ball to shoot at and which pocket to aim for (maybe we could find open source pool AI someplace?)

LIAR'S DICE
Players all roll dice, and can only see their hand. The first player to go needs to guess how many of a certain number were rolled by all players in the game and place a bet. The game then rotates around the table, and players have 3 choices- raise the bet and guess a higher number of dice, fold, or challenge the previous player as a liar. If the bluff is successfully called, then the player whose guess was bad is eliminated from the round. If the guess was right, and there are as many or less than the person guessed, then the person who was called out wins the money and the player who made the challenge is eliminated from the round. The last player in the game gets all of the money and then the game starts with a new round.
In order for the game to work, we need different personalities for AIs, otherwise it will become very easy to beat, or it won't be fun because randomness can't be fooled. We need some kind of certainty mechanic to allow AIs to be tricked, and maybe we could even incorporate player's charisma skills into the game.

Implementation: scene, dice-hand UI, elimination mechanic, AI, dice rolling, assets

DICE AND SHOVE
Each player has two pieces- an X and an O. They take turns rolling a 6-sided die to decide how far they can move their X, and the goal of both players is to push the opponent's O off the 10x5 board. The more speed an X builds up by moving in the same direction longer, the farther it can shove the opposing O.
Because of the luck involved, this makes for a natural gambling game, though strategy does play a role and players could potentially beat the odds with skilled planning.

Implementation: scene, shoving mechanic, AI, dice rolling, assets

OTHER GAMBLING GAMES
?

Implementation: ?

